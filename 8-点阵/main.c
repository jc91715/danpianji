#include <reg52.h>
#include <intrins.h>

typedef unsigned char u8;
typedef unsigned int u16;

sbit SRCLK=P3^6;
sbit RCLK1=P3^5;
sbit SER=P3^4;

//u8 code smgduan[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71};

u8 code ledduan[]={0x00,0x00,0x3e,0x41,0x41,0x41,0x3e,0x00};
u8 code ledwei[]={0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe};

u8 code CHARCODE[18][8]={
{0x00,0x00,0x3e,0x41,0x41,0x41,0x3e,0x00}, //0
{0x00,0x00,0x00,0x00,0x21,0x7f,0x01,0x00}, //1
{0x00,0x00,0x27,0x45,0x45,0x45,0x39,0x00}, //2
{0x00,0x00,0x22,0x49,0x49,0x49,0x36,0x00}, //3
{0x00,0x00,0x0c,0x14,0x24,0x7f,0x04,0x00}, //4
{0x00,0x00,0x72,0x51,0x51,0x51,0x4e,0x00}, //5
{0x00,0x00,0x3e,0x49,0x49,0x49,0x26,0x00}, //6
{0x00,0x00,0x40,0x40,0x40,0x4f,0x70,0x00}, //7
{0x00,0x00,0x36,0x49,0x49,0x49,0x36,0x00}, //8
{0x00,0x00,0x32,0x49,0x49,0x49,0x3e,0x00}, //9
{0x00,0x00,0x7F,0x48,0x48,0x30,0x00,0x00}, //P
{0x00,0x00,0x7F,0x48,0x4C,0x73,0x00,0x00}, //R
{0x00,0x00,0x7F,0x49,0x49,0x49,0x00,0x00}, //E
{0x00,0x00,0x3E,0x41,0x41,0x62,0x00,0x00}, //C
{0x00,0x00,0x7F,0x08,0x08,0x7F,0x00,0x00}, //H
{0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00}, //I
{0x00,0x7F,0x10,0x08,0x04,0x7F,0x00,0x00}, //N
{0x7C,0x48,0x48,0xFF,0x48,0x48,0x7C,0x00}  //中
};

void delay(u16 i){
	while(i--);
}

//显示一列 节省了IO口
void Hc595SendByte(u8 dat){
	
	u8 a;
	SRCLK=0;
	RCLK1=0;
	
	for(a=0;a<8;a++){
		SER=dat>>7;//传最高位，没有改变dat的值
		dat<<=1;//让第二位在最高位，下一次发送
		SRCLK=1;//上升沿有效
		_nop_();
		_nop_();
		SRCLK=0;//为了下一次上升
	}
	RCLK1=1;
	_nop_();
	_nop_();
	RCLK1=0;

}

////显示数字0
//void main()
//{
//	u8 i;
//	
////	Hc595SendByte(0x80);//最高位高电平
////	P0=0x7f;//
//	while(1){
//		P0=0x7f;//第一列点亮
//		for(i=0;i<8;i++){//动态扫描显示8列
//			P0=ledwei[i];//依次点亮每-列（当每一列有高电平的时候，这个点才亮），相当于，在这一列的时候，显示什么数字，和数码管显示一个原理
//			Hc595SendByte(ledduan[i]);//高电平有效
//			delay(100);
//			Hc595SendByte(0x00);
//		}
//	}
//	
//}

void xunhuan(u8 i,u8 j){
		for(i=0;i<8;i++){//动态扫描显示8列
				P0=ledwei[i];//依次点亮每-列（当每一列有高电平的时候，这个点才亮），相当于，在这一列的时候，显示什么数字，和数码管显示一个原理
				Hc595SendByte(CHARCODE[j][i]);//高电平有效 
				delay(100);
				Hc595SendByte(0x00);
			}
}

//动态显示数字
void main()
{
	u8 ti,i,j=0;
	
	while(1){
		//delay(50000);
		//P0=0xff;
		
		
		for(ti=0;ti<50000;ti++){//todo 一直显示0？
			xunhuan(i,j);
		}
	

		
		delay(50000);
		j++;
		
		if(j == 18){
			j = 0;
		}
		
	}
	
}
